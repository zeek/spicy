#! /usr/bin/env python3

import argparse
import sys

# Main


def error(msg):
    print("error: {}".format(msg), file=sys.stderr)
    sys.exit(1)


parser = argparse.ArgumentParser()
parser.add_argument("nodes", nargs="*", metavar="nodes",
                    action="store", help="nodes.decl file")
parser.add_argument("--output", dest="output", action="store",
                    default=None, required=True, help="Output file")
parser.add_argument("--header", dest="headers", action="append", default=[],
                    required=False, help="Header to include in generated file")

args = parser.parse_args()
out = open(args.output, "w")

print('#pragma once\n', file=out)

for header in args.headers:
    print("#include <{}>\n".format(header), file=out)

print("#define VISITOR_DISPATCHERS \\", file=out)

traits = {}
nodes = []

for f in args.nodes:
    for line in open(f):
        line = line.strip()
        if not line or line.startswith("//"):
            continue

        if line.startswith("trait"):
            m = line.split()
            traits[m[2]] = m[1]
            continue

        m = line.split(" : ")
        cls = m[0]
        trait = m[1] if len(m) > 1 else "isNode"

        nodes.append((cls, trait))

for (cls, trait) in nodes:
    if trait not in traits:
        print("No 'trait' definition for {}".format(trait), file=sys.stderr)
        sys.exit(1)

for (btrait, bcls) in traits.items():
    print("  if constexpr ( std::is_base_of_v<{}, Erased> && std::is_base_of_v<hilti::type::Visitor, Dispatcher> ) {{ \\".format(
        bcls), file=out)

    if bcls == "hilti::Type":
        print("    if constexpr ( std::is_const_v<decltype(i.node)> ) {\\", file=out)
        print("      n.dispatch(d, i); \\", file=out)
        print("    } else {\\", file=out)
        # Types can only be dispatched on with mutable position, adjust received data.
        print("      using P__ = std::decay_t<decltype(i)>; \\", file=out)
        print("      using N__ = std::add_lvalue_reference_t<typename P__::Erased>; \\", file=out)
        print("      auto& n__ = const_cast<N__>(i.node); \\", file=out)
        print("      std::vector<hilti::visitor::Location<N__>> path__; path__.reserve(i.path.size());\\", file=out)
        print("      for ( auto&& x: i.path ) path__.push_back(hilti::visitor::Location<N__>{const_cast<N__>(x.node), x.child}); \\", file=out)
        print("      hilti::visitor::Position<N__> ii = {n__, path__}; \\", file=out)
        print("      n.dispatch(d, ii); \\", file=out)
        print("    }\\", file=out)

    else:
        for (cls, trait) in nodes:
            if trait != btrait:
                continue

            def output(msg):
                print(msg.format(cls=cls) + " \\", file=out)

            output(
                "    if ( auto r = do_dispatch_one<Result, {cls}, Erased, Dispatcher, Iterator>(n, tn, d, i, no_match_so_far) ) return r;")

    print("  } \\", file=out)
    print(" \\", file=out)

print("", file=out)
