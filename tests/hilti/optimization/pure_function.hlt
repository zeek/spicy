# @TEST-DOC: Checks marking of functions as pure.
#
# @TEST-EXEC: HILTI_OPTIMIZER_PASSES=pure_function hiltic -p %INPUT -o opt.hlt -D optimizer >output 2>&1
# @TEST-EXEC: btest-diff output
# @TEST-EXEC: btest-diff opt.hlt

module foo {

function uint<64> fn_pure() {
    local x = 0;
    x += 1;
    fn_pure2();
    return 0;
}

function void fn_pure2() {}

global uint<64> num_calls = 0;

function uint<64> fn_not_pure() {
    num_calls += 1;
    fn_pure();
    return 0;
}

type X = struct {
    hook void ~finally() {}
};

type T = struct {
    method void pure() {}
    method int<64> pure2() { return 0; }

    # Calls of this method cannot be elided since it returns a struct with lifetime hooks.
    method X pure3() {
        local X x;
        return x;
    }

    method void pure4();
};

method void T::pure4() {
    # This should be recognized as side-effect free.
    self;
}

global T t;
t.pure4();

# Parameter access is side-effect free for `in` and `copy` parameters if they are not of reference type.
function void fn_pure5(uint<64> in_param) { in_param += 42; }
function void fn_pure6(copy uint<64> copy_param) { copy_param += 42; }
function void fn_not_pure2(inout uint<64> inout_param) { inout_param += 42; }

function void fn_not_pure3(strong_ref<uint<64>> in_param) { *in_param += 42; }
function void fn_not_pure4(copy strong_ref<uint<64>> copy_param) { *copy_param += 42; }
function void fn_not_pure2(inout strong_ref<uint<64>> inout_param) { *inout_param += 42; }


}
