# @TEST-DOC: Checks marking of functions as pure.
#
# @TEST-EXEC: HILTI_OPTIMIZER_PASSES=pure_function hiltic -p %INPUT -o opt.hlt -D optimizer >output 2>&1
# @TEST-EXEC: btest-diff output
# @TEST-EXEC: btest-diff opt.hlt

module foo {

function uint<64> fn_pure() {
    local x = 0;
    x += 1;
    fn_pure2();
    return 0;
}

function void fn_pure2() {}

global uint<64> num_calls = 0;

function uint<64> fn_not_pure() {
    num_calls += 1;
    fn_pure();
    return 0;
}

type X = struct {
    hook void ~finally() {}
};

type T = struct {
    method void pure() {}
    method int<64> pure2() { return 0; }

    # Calls of this method cannot be elided since it returns a struct with lifetime hooks.
    method X pure3() {
        local X x;
        return x;
    }

    method void pure4();
};

method void T::pure4() {
    # This should be recognized as side-effect free.
    self;
}

global T t;
t.pure4();

}
