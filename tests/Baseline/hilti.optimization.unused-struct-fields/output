### BTest baseline data generated by btest-diff. Do not edit. Use "btest -U/-u" to update. Requires BTest >= 0.63.
("1", "unset optional value")
("2", "struct attribute not set")
[$not_accessed_at_all=(optimized out), $not_accessed_at_all_either_but_always_emit=(not set), $only_reads=(optimized out), $only_reads_no_default=(optimized out), $only_writes=(optimized out)]
[$not_accessed_at_all_but_type_is_exported=""]
----
[debug/optimizer-passes]     Test::X::not_accessed_at_all  #reads=0 #writes=0 #unsets=0
[debug/optimizer-passes]     Test::X::only_reads  #reads=5 #writes=0 #unsets=1
[debug/optimizer-passes]     Test::X::only_reads_no_default  #reads=2 #writes=0 #unsets=0
[debug/optimizer-passes]     Test::X::only_writes  #reads=0 #writes=7 #unsets=1
----
module Test {

import hilti;

type X = struct {
    string not_accessed_at_all &optional &no-emit="optimized";
    string not_accessed_at_all_either_but_always_emit &always-emit &optional;
    string only_reads &optional &default="" &no-emit="optimized";
    string only_reads_no_default &optional &no-emit="optimized";
    string only_writes &optional &no-emit="optimized";
};
type ExportedType = struct {
    string not_accessed_at_all_but_type_is_exported;
};

export ExportedType;

global X x = [];
global uint<64> tmp;
global ExportedType y;

function tuple<uint<64>, string> t() {
    return (42, "t()");
}

public function void member_const(X x) {
    assert "" == "";
}

public function void member_non_const(inout X x) {
    assert "" == "";
}

assert "" == "";
assert True;
assert "" == "";
(tmp) = (42);
(tmp) = ({local tuple<uint<64>, string> _t_elem = t();} (_t_elem[0]));
try {
    assert (hilti::throw_unset_optional(), default<string>()) == "";
}
catch ( hilti::Exception e ) {
    hilti::print(("1", e.description()), True);
}

try {
    assert (hilti::throw_attribute_not_set(), default<string>()) == "";
}
catch ( hilti::Exception e ) {
    hilti::print(("2", e.description()), True);
}

hilti::print(x, True);
hilti::print(y, True);

}
